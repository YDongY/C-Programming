# 数据类型

## 进制

- 十进制（Decimal）
- 八进制（Octal）
- 二进制（Binary）
- 十六进制（Hexadecimal）

### 任意进制转十进制

一个 R 进制数：`k3k2k1k0.s1s2s3` 转十进制

```
k3*R^3 + k2*R^2 + k1*R^1 + k0*R^0 + s1*R^(-1) + s2*R^(-2) + s3*R^(-3)
```

### 十进制转任意进制

- 整数转换：除 R 取余法（bottom-top）
- 小数转换：乘 R 取整法（top-bottom）

### 代码书写

```C
int decimal = 24;//十进制
int hex = 0x2B; // 十六进制
int binary = 024; // 八进制

// C 语言标准不支持二进制表示，GCC 编译器支持
int binary = 0b101010; //二进制

printf("十进制：%d",20); // 20
printf("十进制：%i",20); // 20
printf("八进制：%o",20); // 24
printf("十六进制：%x",20); // 14
```

## 存储单位

- 1字 = 2B
- 1KB = 1024B = 2^10B
- 1MB = 1024KB = 2^20B
- 1GB = 1024MB = 2^30B

> 在内存中，每个字节都有自己的编号（内存地址）

## sizeof 运算符

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{

    // sizeof 运算符
    int i1 = 10;
    int i2 = 20;
    int size = sizeof(i1);
    printf("%d \n", size); // 4
    printf("%d \n", sizeof i1); // 4，不推荐
    printf("%d \n", sizeof(int)); // 4

    // 查看内存地址
    printf("%p \n",&i1); // 0x7ffc72f74be8
}
```

## 变量内存地址

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{

    int i1 = 10;
    int i2 = 20;

    // 查看内存地址，变量首字节的内存地址
    printf("%p \n",&i1); // 0x7fffb3da3468
    printf("%p \n",&i2); // 0x7fffb3da3464

    // 先声明的 i1 内存地址大，后声明的 i2 内存地址小
}
```

由于计算机只能识别 0 和 1 ，所以每一个字节中的数据都是以二进制形式存储的。一个字节包含 8 个二进制位，每一个二进制位存储一个 0 或 1.

1Byte = 8bit ,1B = 8b

```C
----------------------------------------------
| 变量 |   内存地址    |         字节           |
----------------------------------------------
|     |0x7fffb3da3464|  |  |  |  |  |  |  |  |  \
|     |0x7fffb3da3465|  |  |  |  |  |  |  |  |   \
| i2  |0x7fffb3da3466|  |  |  |  |  |  |  |  |   / 32bit
|     |0x7fffb3da3467|  |  |  |  |  |  |  |  |  /
----------------------------------------------
|     |0x7fffb3da3468|  |  |  |  |  |  |  |  |  \
|     |0x7fffb3da3469|  |  |  |  |  |  |  |  |   \
| i1  |0x7fffb3da346A|  |  |  |  |  |  |  |  |   / 32bit
|     |0x7fffb3da346B|  |  |  |  |  |  |  |  |  /
----------------------------------------------
```

## 原码、反码、补码

```C
// 原码

 有符号数   符号位        数值位
----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------

// 反码
// - 正数反码：和原码一样
// - 负数反码：原码按位取反

----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 1 | 1 | 1 | 0 | 1 | 0 | 0 |
----------------------------------------------

// 补码
// - 正数补码：和原码一样
// - 负数补码：反码末位+1
----------------------------------------------
| +11   |   0    | 0 | 0 | 0 | 1 | 0 | 1 | 1 |
----------------------------------------------
| -11   |   1    | 1 | 1 | 1 | 0 | 1 | 0 | 1 |
----------------------------------------------

```

**在计算机中，数值一律采用补码来表示和存储**

## 大小端模式

> 决定字节数据的字节存储顺序

```C

// 整数的补码表示

  高字节                                 低字节
-------------------------------------------------
| 0001 0001 | 0010 0010 | 0100 0100 | 1000 1000 |
-------------------------------------------------

// -------------- 大端模式 -----------------------
// 高字节放低地址，低字节放高地址

------------------------------------------------
|   内存地址    |       字节                     |
------------------------------------------------
|0x7fffb3da3464| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 高字节
|0x7fffb3da3465| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |   |
|0x7fffb3da3466| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |   |
|0x7fffb3da3467| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 低字节
------------------------------------------------


// -------------- 小端模式 -----------------------
// 高字节放高地址，低字节放低地址

------------------------------------------------
|   内存地址    |       字节                     |
------------------------------------------------
|0x7fffb3da3464| 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 低字节
|0x7fffb3da3465| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |   |
|0x7fffb3da3466| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |   |
|0x7fffb3da3467| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 高字节
------------------------------------------------
```

## 字符类型

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
  char ch = 'a';
  printf("ch = %d\n", ch); // ch = 97
  printf("ch = %c\n", ch); // ch = a

  int i = 'a';
  char c = 97

  printf("%d %d \n",i,c) // 97 97
  printf("%c %c \n",i,c) // a  a
}
```

一个 `char` 类型的变量占用 1 个字节的内存。下面是错误的写法：

```C
char ch1 = 'ab'; // 一个字符占用一个字节
char ch2 = '中'; // 一个中文字符至少占用 2 个字节
char ch3 = "中"; // 字符定义，使用双引号
```

表面上看上去的字符，在计算机中实际是以二进制形式存储，**每个字符都会被转化为对应的整数值（ASCII）进行存储**

### 非英文字符如何存储？

常用编码：

- GBK（主要支持中国、日本、韩国字符）
- UTF-8（支持几乎世界上所有字符）

## 转义字符

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
  char c = '\\'; // 反斜杠
  char n = '\n'; // 换行
  char r = '\r'; // 回车
  char t = '\t'; // tab
  char b = '\b'; // 退格
}
```

## 数据类型

- 基本类型
  - 字符类型
  - 有符号整数类型
  - 无符号整数类型
  - 浮点类型
- 枚举类型
- 派生类型
- void 类型

### 基本类型

- **整数类型**

| 类型                | 存储大小    | 值范围                                        |
| :-------------------| :---------- | :------------------------------------------|
| char                | 1 字节      | -128 - 127                                   |
| unsigned char       | 1 字节      | 0 - 255                                     |
| signed char         | 1 字节      | -128 - 127                                  |
| int                 | 2 或 4 字节 | -32768 - 32767 或 -2147483648  - 2147483647  |
| unsigned int        | 2 或 4 字节 | 0 - 65535 或 0 - 4294967295                  |
| short               | 2 字节      | -32768 - 32767                              |
| unsigned short      | 2 字节      | 0 - 65535                                   |
| long                | 4 字节      | -2147483648 - 2147483647                    |
| unsigned long       | 4 字节      | 0 - 4294967295                              |
| long long           | 8 字节      | -9223372036854775808 - 9223372036854775807  |
| unsigned long long  | 8 字节      | 0 - 18446744073709551615                    |

- **数据模型**

  - 32bit系统（Win32 API、Unix、Linux、Mac OS X）
    - LP32（2/4/4）：int 为 2 字节，long 和 指针 4 字节
    - ILP32（4/4/4）：int 为 4 字节，long 和 指针 4 字节
  - 64bit系统（Win64 API、Unix、Linux、Mac OS X）
    - LLP64（4/4/8）：int 和 long 为 4 字节， 指针 8 字节
    - LP64（4/8/8）：int 为 4 字节，long 和 指针 8 字节

  - ILP64（8/8/8）：int 、long 、指针均为 8 字节


- **浮点类型（IEEE 754）**

| 类型        | 存储大小 | 值范围                | 精度      |
| :---------- | :------- | :-------------------- | :-------- |
| float       | 4 字节   | -3.4E-38  - 3.4E+38    | 6 位小数  |
| double      | 8 字节   | -1.8E-308 - 1.8E+308   | 15 位小数 |
| long double | 16 字节  | -1.2E-4932 - 1.2E+4932 | 19 位小数 |

## 输入输出

| 打印格式          | 含义                                                    |      |
| ----------------- | ------------------------------------------------------- | ---- |
| `%d`              | 输出一个有符号的 10 进制 int 类型                       |      |
| `%o`              | 输出 8 进制的 int 类型                                  |      |
| `%x`              | 输出 16 进制的 int 类型，字母小写                       |      |
| `%X`              | 输出 16 进制的 int 类型，字母大写                       |      |
| `%u`              | 输出 unsigned int 类型                                  |      |
| `%l` 或者 `%ll`   | 输出 long 类型 或者 输出 unsigned  long 类型            |      |
| `%lu` 或者 `%llu` | 输出 long  long 类型 或者 输出 unsigned long  long 类型 |      |
| `%hd` 或者 `%hu`  | 输出 short 类型 或者 输出 unsigned short 类型           |      |
| `%f`              | float 输出单精度浮点数                                  |      |
| `%lf`             | double 输出双精度浮点数                                 |      |
| `%e`或者`%E`      | double 科学计数法                                       |      |
| `%s`              | 字符串，输出字符串中的字符直到字符串中的空字符          |      |
| `%c`              | 字符型                                                  |      |
| `%p`              | 以 16 进制形式输出指针                                  |      |
| `%%`              | 输出一个百分号                                          |      |


## 类型转换

> 大类型转小类型可能会丢失精度

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    double a;
    int b = 10;

    a = b;               // 隐式转换
    printf("%lf \n", a); // 10.000000

    double n1 = 6.75;

    int n2 = (int)n1; // 强制类型装换

    printf("%d \n", n2); // 6 ,丢失精度

    return 0;
}
```